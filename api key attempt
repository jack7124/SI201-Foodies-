import base64
import requests
import datetime
import matplotlib.pyplot as plt
import sqlite3

db_path = "foodproject.db"
db_insert_limit = 25
CLIENT_ID = "REDACTED"
CLIENT_SECRET = "REDACTED"


def get_conn():
    conn = sqlite3.connect(db_path)
    conn.row_factory = sqlite3.Row
    return conn

def create_kroger_tables():
    conn = get_conn()
    c = conn.cursor()

    products_table = """CREATE TABLE IF NOT EXISTS products(
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    upc TEXT,
    description TEXT,
    brand TEXT)"""

    # UPC stands for universal product code

    c.execute(products_table)

    ## Using REALs as some are floats 
    items_table = """CREATE TABLE IF NOT EXISTS items(
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    product_id INTEGER,
    location_id TEXT,
    regular_price REAL,
    promo_price REAL,
    stock_level TEXT,
    size TEXT,
    FOREIGN KET(product_id) REFERENCES products(id))"""

    c.execute(items_table)

    price_history_table = """CREATE TABLE IF NOT EXISTS price_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    product_id INTEGER,
    price REAL,
    date TEXT,
    FOREIGN KEY(product_id) REFERENCES products(id))"""

    c.execute(price_history_table)

    conn.commit()
    conn.close()
    
    
    
    





def get_kroger_token(CLIENT_ID, CLIENT_SECRET, TOKEN_URL):
    # Encode client_id:client_secret in base64
    TOKEN_URL = "https://api.kroger.com/v1/connect/oauth2/token"
    auth_str = f"{CLIENT_ID}:{CLIENT_SECRET}"
    auth_b64 = base64.b64encode(auth_str.encode("ascii")).decode("ascii")

    headers_auth = {
        "Authorization": f"Basic {auth_b64}",
        "Content-Type": "application/x-www-form-urlencoded"
    }

    data_auth = {
        "grant_type": "client_credentials",
        "scope": "product.compact"
    }

    print("Requesting Production Access Token...")
    try: 
        response_token = requests.post(TOKEN_URL, headers=headers_auth, data=data_auth)
        response_token.raise_for_status()
        access_token = response_token.json()["access_token"]
        print("   Success! Production Token acquired.\n")
        return access_token
    except requests.exceptions.HTTPError as e:
        print(f"     Auth failed: {e}")
        print(f"     Server Response: {response_token.text}")
        exit()

def fetch_kroger_products(access_token, location_id, term="sugar", limit=50):
    url = "https://api.kroger.com/v1/products"
    headers = {
        "Authorization": f"Bearer {access_token}"
    }

    params = {
        "filter.term": term,
        "filter.locationId": location_id,
        "filter.limit": limit
    }

    try: 
        response_token = requests.get(access_token, headers=headers, params=params)
        response_token.raise_for_status()
        data = response_token.json()["data"]
        print("   Success! Product data acquired.\n")
        return data
    except requests.exceptions.HTTPError as e:
        print(f"     Auth failed: {e}")
        print(f"     Server Response: {response_token.text}")
        exit()
    
def clean_and_transf_kroger(raw_products):
    cleaned = []

    for product in raw_products:
        item = product.get("items", [{}])[0]
        price_obj = item.get("price") or item.get("nationalPrice") or {}
        
        cleaned.append({
            "upc": product.get("upc"),
            "description": product.get("description"),
            "brand": product.get("brand"),

            "regular_price": price_obj.get("regular"),
            "promo_price": price_obj.get("promo"),
            "stock_level": (item.get("inventory") or {}).get("stockLevel"),
            "size": item.get("size")})
        
    return cleaned 

def into_krogerdb(products, location_id):
    conn = get_conn()
    cur = conn.cursor()
    inserted = 0

    for product in products:
        if inserted >= db_insert_limit:
            break 

    cur.execute(f"SELECT id FROM products WHERE upc = '{product['upc']}'")
    row = cur.fetchone()

    if row:
        product_id = row["id"]
    else:

        cur.execute(f"""INSERT OR IGNORE INTO products (upc, description, brand)
                    VALUES ('{product["upc"]}, '{product["description"]}, '{product["brand"]}')
                    """)
        conn.commit()

        cur.execute(f"SELECT id FROM products WHERE upc = '{product['upc']}'")

        product_id = cur.fetchone()["id"]

    cur.execute(f"""
            INSERT OR IGNORE INTO items (
                product_id, location_id,
                regular_price, promo_price, stock_level, size
            )
            VALUES (
                {product_id},
                '{location_id}',
                {product["regular_price"]},
                {product["promo_price"]},
                '{product["stock_level"]}',
                '{product["size"]}'
            )
        """)

    conn.commit()
    inserted += 1

    conn.close()
    return inserted

def save_price_hist():
    conn = get_conn()
    cur = conn.cursor()

    today = str(datetime.date.today())

    cur.execute("SELECT id, regular_price FROM items WHERE regular_price IS NOT NULL")

    rows = cur.fetchall()

    for row in rows:
        cur.execute(f"""
                    INSERT INTO price_history (product_id, price, date)
                    VALUES ({row["id"]}, {row["regular_price"]}, '{today}')
                    """
                    )
        
    conn.commit()
    conn.close()


def kroger_calculations():
    conn = get_conn()
    cur = conn.cursor()

    out = []

    #### Price per unit

    cur.execute(""" 
                SELECT products.description, items.size, items.regular_price
                FROM products
                JOIN items on products.id = items.product_id """)
    price_per_unit= []

    for row in cur.fetchall():
        size = row['size']
        price = row['regular_price']

        if size and price:
            try:
                amount = float(size.split()[0])
                unit_amount = round(price / amount, 4)
                price_per_unit.append((row["description"], unit_amount))
            except:
                continue

    out.append(f"Computed price per unit for {len(price_per_unit)} products")

    #### Cheapest item
    if price_per_unit:
        cheapest = min(price_per_unit, key=lambda x: x[1])
        out.append(f"The cheapest item found out of {len(price_per_unit)} products is {cheapest[0]} (${cheapest[1]})")
    





            





    















# Setting ann arbor kroger location and a product to search
zipcode = "48104"
searchterm = "sugar" 